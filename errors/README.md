## 期望错误码实现功能
1. 有业务Code码标识
2. 能够区分内外并展示不同的错误信息

## 错误码设计
1. 区别HTTP状态码，业务码要有一定的规则
2. 请求出错时，可以通过HTTP码直接感知请求出错
3. 需求出错时，返回详细信息，包括：业务Code、错误信息、参考文档（可选）
4. 返回的错误信息，需要是安全的客户可见信息，敏感信息不可以对客户显示。同时内部要有详细的错误信息
5. 返回数据格式是固定的、规范的
6. 错误信息保存简洁，并提供有用的信息

## 业务码设计
设计规范：纯数字表示、不同部位代表不同的服务、不同的模块、例如100101，说明如下：
+ 10：服务
+ 01：某个服务下的某个模块
+ 01：模块下的错误序号，每个模块最多注册100个错误

## 设置HTTP状态码
+ 1XX（指示信息） 表示请求已接收、继续处理
+ 2XX（请求成功） 表示成功处理请求的状态代码
+ 3XX（请求被重定向） 表示要完成请求，需要进一步操作。
+ 4XX（请求错误） 表示请求可能出错，一般为客户端的错误
+ 5XX（服务器错误） 表示服务器在尝试处理请求时发生了内部错误。

## 错误包
+ 支持错误堆栈
+ 支持不同的打印方式
+ 支持Wrap/UnWrap功能
+ 有Is方法
+ 支持As函数
+ 支持格式化和非格式化错误创建

- - -
### 1.支持错误堆栈
可以输出调式信息，帮助我们定位问题，表明具体哪行代码报错

### 2.支持不同的打印格式
错误包支持不同的打印格式，例如%+v, %v, %s等格式，

### 3.支持Wrap/UnWarp功能
在已有错误的基础上，可以追加一些新的信息。例如
```
    errors.Warp(err,"open file failed")
```
**Warp**功能通常用在调用函数中。调用函数可以基于被调函数报错时的错误封装一些自己的信息，丰富报错信息，方便后期的错误定位。|| 调用Warp时，也会生成错误堆栈节点，这个错误堆栈可以使用UnWarp函数获取。

### 4.有Is方法
判断某个error是否是指定的error。当err和target是同一个，或者err是一个嵌套error时，如果target也包含在这个嵌套error链中，放回ture，否则返回fasle

### 5.支持As函数
通过实现As函数，放回err或者嵌套的error，将目标error转为另外一个error。实现类型断言的功能。

### 6.支持格式化和非格式化错误创建
支持两种错误创建方法。例如
```go
    errors.New("file not found")
    errors.Errorf("file %s not found", "iam-apiserver")
```
- - -
推荐的errors包

1. `github.com/pkg/errors` 

2. `github.com/marmotedu/errors` 在[1]上做了封装